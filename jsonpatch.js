// Generated by CoffeeScript 1.3.3
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function(root, factory) {
    if (typeof exports !== 'undefined') {
      return factory(root, exports);
    } else if (typeof define === 'function' && define.amd) {
      return define(['exports'], function(exports) {
        return root.jsonpatch = factory(root, exports);
      });
    } else {
      return root.jsonpatch = factory(root, {});
    }
  })(this, function(root) {
    var InvalidPatchError, JSONPatch, JSONPatchError, JSONPointer, PatchConflictError, add, apply, compile, hasOwnProperty, isArray, isEqual, isObject, isString, memberProcessors, methodMap, move, operationMembers, remove, replace, test, toString, _isEqual;
    toString = Object.prototype.toString;
    hasOwnProperty = Object.prototype.hasOwnProperty;
    isArray = function(obj) {
      return toString.call(obj) === '[object Array]';
    };
    isObject = function(obj) {
      return toString.call(obj) === '[object Object]';
    };
    isString = function(obj) {
      return toString.call(obj) === '[object String]';
    };
    _isEqual = function(a, b, stack) {
      var className, key, length, result, size;
      if (a === b) {
        return a !== 0 || 1 / a === 1 / b;
      }
      if (a === null || b === null) {
        return a === b;
      }
      className = toString.call(a);
      if (className !== toString.call(b)) {
        return false;
      }
      switch (className) {
        case '[object String]':
          String(a) === String(b);
          break;
        case '[object Number]':
          a = +a;
          b = +b;
          if (a !== a) {
            b !== b;
          } else {
            if (a === 0) {
              1 / a === 1 / b;
            } else {
              a === b;
            }
          }
          break;
        case '[object Boolean]':
          +a === +b;
      }
      if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
      }
      length = stack.length;
      while (length--) {
        if (stack[length] === a) {
          return true;
        }
      }
      stack.push(a);
      size = 0;
      result = true;
      if (className === '[object Array]') {
        size = a.length;
        result = size === b.length;
        if (result) {
          while (size--) {
            if (!(result = __indexOf.call(a, size) >= 0 === __indexOf.call(b, size) >= 0 && _isEqual(a[size], b[size], stack))) {
              break;
            }
          }
        }
      } else {
        if (__indexOf.call(a, "constructor") >= 0 !== __indexOf.call(b, "constructor") >= 0 || a.constructor !== b.constructor) {
          return false;
        }
        for (key in a) {
          if (hasOwnProperty.call(a, key)) {
            size++;
            if (!(result = hasOwnProperty.call(b, key) && _isEqual(a[key], b[key], stack))) {
              break;
            }
          }
        }
        if (result) {
          for (key in b) {
            if (hasOwnProperty.call(b, key) && !size--) {
              break;
            }
          }
          result = !size;
        }
      }
      stack.pop();
      return result;
    };
    isEqual = function(a, b) {
      return _isEqual(a, b, []);
    };
    JSONPatchError = (function(_super) {

      __extends(JSONPatchError, _super);

      function JSONPatchError(message) {
        this.name = 'JSONPatchError';
        this.message = message || 'JSON patch error';
      }

      return JSONPatchError;

    })(Error);
    InvalidPatchError = (function(_super) {

      __extends(InvalidPatchError, _super);

      function InvalidPatchError(message) {
        this.name = 'InvalidPatch';
        this.message = message || 'Invalid patch';
      }

      return InvalidPatchError;

    })(JSONPatchError);
    PatchConflictError = (function(_super) {

      __extends(PatchConflictError, _super);

      function PatchConflictError(message) {
        this.name = 'PatchConflictError';
        this.message = message || 'Patch conflict';
      }

      return PatchConflictError;

    })(JSONPatchError);
    JSONPointer = (function() {

      function JSONPointer(path, shouldExist) {
        var i, loc, steps, _i, _len;
        if (shouldExist == null) {
          shouldExist = true;
        }
        if (path && (steps = path.split('/')).shift() !== '') {
          throw new InvalidPatchError();
        }
        for (i = _i = 0, _len = steps.length; _i < _len; i = ++_i) {
          loc = steps[i];
          steps[i] = decodeURIComponent(loc);
        }
        this.accessor = steps.pop();
        this.path = steps;
      }

      JSONPointer.prototype.getObject = function(obj) {
        var loc, _i, _len, _ref;
        _ref = this.path;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          loc = _ref[_i];
          if (isArray(obj)) {
            loc = parseInt(loc, 10);
          }
          if (!(loc in obj)) {
            throw new PatchConflictError('Array location out of bounds or not an instance property');
          }
          obj = obj[loc];
        }
        return obj;
      };

      return JSONPointer;

    })();
    JSONPatch = (function() {

      function JSONPatch(patch) {
        var key, member, method, preproc, supp;
        for (key in patch) {
          if (!(method = methodMap[key])) {
            continue;
          }
          if (this.operation) {
            throw new InvalidPatchError();
          }
          if ((member = operationMembers[key]) && patch[member] === void 0) {
            throw new InvalidPatchError("Patch member " + member + " not defined");
          }
          this.operation = methodMap[key];
          this.pointer = new JSONPointer(patch[key]);
          supp = patch[member];
          if ((preproc = memberProcessors[key])) {
            supp = preproc(supp);
          }
          this.supplement = supp;
        }
        if (!this.operation) {
          throw new InvalidPatchError();
        }
      }

      JSONPatch.prototype.apply = function(obj) {
        return this.operation(obj, this.pointer, this.supplement);
      };

      return JSONPatch;

    })();
    add = function(root, pointer, value) {
      var acc, obj;
      obj = pointer.getObject(root);
      acc = pointer.accessor;
      if (isArray(obj)) {
        acc = parseInt(acc, 10);
        if (acc < 0 || acc > obj.length) {
          throw new PatchConflictError("Index " + acc + " out of bounds");
        }
        obj.splice(acc, 0, value);
      } else {
        if (acc in obj) {
          throw new PatchConflictError("Value at " + acc + " exists");
        }
        obj[acc] = value;
      }
    };
    remove = function(root, pointer) {
      var acc, obj;
      obj = pointer.getObject(root);
      acc = pointer.accessor;
      if (isArray(obj)) {
        acc = parseInt(acc, 10);
        if (!(acc in obj)) {
          throw new PatchConflictError("Value at " + acc + " does not exist");
        }
        obj.splice(acc, 1);
      } else {
        if (!(acc in obj)) {
          throw new PatchConflictError("Value at " + acc + " does not exist");
        }
        delete obj[acc];
      }
    };
    replace = function(root, pointer, value) {
      var acc, obj;
      obj = pointer.getObject(root);
      acc = pointer.accessor;
      if (isArray(obj)) {
        acc = parseInt(acc, 10);
        if (!(acc in obj)) {
          throw new PatchConflictError("Value at " + acc + " does not exist");
        }
        obj.splice(acc, 1, value);
      } else {
        if (!(acc in obj)) {
          throw new PatchConflictError("Value at " + acc + " does not exist");
        }
        obj[acc] = value;
      }
    };
    test = function(root, pointer, value) {
      var acc, obj;
      obj = pointer.getObject(root);
      acc = pointer.accessor;
      if (isArray(obj)) {
        acc = parseInt(acc, 10);
      }
      return isEqual(obj[acc], value);
    };
    move = function(root, from, to) {
      var acc, obj, value;
      obj = from.getObject(root);
      acc = from.accessor;
      if (isArray(obj)) {
        acc = parseInt(acc, 10);
        if (!(acc in obj)) {
          throw new PatchConflictError("Value at " + acc + " does not exist");
        }
        value = obj.splice(acc, 1)[0];
      } else {
        if (!(acc in obj)) {
          throw new PatchConflictError("Value at " + acc + " does not exist");
        }
        value = obj[acc];
        delete obj[acc];
      }
      obj = to.getObject(root);
      acc = to.accessor;
      if (isArray(obj)) {
        acc = parseInt(acc, 10);
        if (acc < 0 || acc > obj.length) {
          throw new PatchConflictError("Index " + acc + " out of bounds");
        }
        obj.splice(acc, 0, value);
      } else {
        if (acc in obj) {
          throw new PatchConflictError("Value at " + acc + " exists");
        }
        obj[acc] = value;
      }
    };
    methodMap = {
      add: add,
      remove: remove,
      replace: replace,
      move: move,
      test: test
    };
    operationMembers = {
      add: 'value',
      remove: null,
      replace: 'value',
      test: 'value',
      move: 'to'
    };
    memberProcessors = {
      move: function(to) {
        return new JSONPointer(to);
      }
    };
    apply = function(root, patchDocument) {
      return compile(patchDocument)(root);
    };
    compile = function(patchDocument) {
      var operations, patch, _i, _len;
      operations = [];
      for (_i = 0, _len = patchDocument.length; _i < _len; _i++) {
        patch = patchDocument[_i];
        operations.push(new JSONPatch(patch));
      }
      return function(root) {
        var op, result, _j, _len1;
        for (_j = 0, _len1 = operations.length; _j < _len1; _j++) {
          op = operations[_j];
          result = op.apply(root);
        }
        return result;
      };
    };
    root.apply = apply;
    root.compile = compile;
    root.JSONPatchError = JSONPatchError;
    root.InvalidPatchError = InvalidPatchError;
    root.PatchConflictError = PatchConflictError;
    return root;
  });

}).call(this);
